# -*- coding: utf-8 -*-
"""COMPARING_INVESTMENT_STRATEGIES-HW5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MKH7nCcz6mk-48tHIGXepqh1-DbzraGX
"""

!pip install yfinance

"""Names: Ousama Batais & John Thomas
NetIDs: oxb220001 & jxt200031
"""

# Import required libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Function to download historical data for a given stock
def get_stock_data(ticker):
    data = yf.download(ticker, start="1994-01-01", end="2024-01-01", interval="1mo")
    data = data['Close'].dropna()  # Keep only closing prices and drop NaN values
    return data

# Example: Get historical data for Apple (AAPL)
ticker = "AAPL"
stock_data = get_stock_data(ticker)

# Ensure all data is numeric
stock_data = stock_data.astype(float)

print(stock_data.head(20))  # Check the first 20 rows of the dataset
print(stock_data.tail(20))  # Check the last 20 rows of the dataset
print(stock_data.info())    # Verify the data types and non-null counts

"""### Strategy Simulation"""

# Signal Generation Function
def generate_signals(data, short_window=5, long_window=20):
    # Ensure it's a DataFrame with column "Price"
    # If 'data' is already a DataFrame, rename the first column to 'Price'
    if isinstance(data, pd.DataFrame):
        data = data.rename(columns={data.columns[0]: 'Price'})
    else:
        # If 'data' is a Series, convert it to a DataFrame with column name 'Price'
        data = data.to_frame(name="Price")

    data['SMA_short'] = data['Price'].rolling(window=short_window).mean()
    data['SMA_long'] = data['Price'].rolling(window=long_window).mean()
    data['Signal'] = np.where(data['SMA_short'] > data['SMA_long'], 'Buy', 'Sell')

    # Drop rows with NaN values
    data.dropna(inplace=True)

    # Debugging signals
    print(data.tail(10))  # Last 10 rows of signal data
    return data

# Ensure stock_data is in the correct format and has the 'Price' column
if isinstance(stock_data, pd.Series):
    stock_data = stock_data.to_frame(name="Price")  # Convert Series to DataFrame if necessary
else:
    stock_data.rename(columns={stock_data.columns[0]: 'Price'}, inplace=True)  # Rename column to 'Price'

# Generate signals
signals = generate_signals(stock_data, short_window=5, long_window=20)

# Display results
print(signals.head(10))
print(signals.tail(10))

# Buy and Hold Strategy Simulation
def simulate_buy_and_hold(data):
    monthly_investment = 1000
    total_invested = 0
    total_shares = 0

    # Iterate over the 'Price' column values
    for price in data['Price']:
        total_invested += monthly_investment
        total_shares += monthly_investment / price

    # Calculate the final portfolio value using the last price
    final_value = total_shares * data['Price'].iloc[-1]
    return final_value, total_invested

def simulate_active_trading(data):
    monthly_investment = 1000
    cash = 0
    shares = 0
    position = "Sell"  # Start with cash

    print(f"{'Month':<10}{'Price':<10}{'Signal':<10}{'Position':<10}{'Cash':<15}{'Shares':<10}")
    for i in range(len(data)):
        price = data['Price'].iloc[i]
        signal = data['Signal'].iloc[i]

        # Print current state for debugging
        print(f"{i + 1:<10}{price:<10.2f}{signal:<10}{position:<10}{cash:<15.2f}{shares:<10.4f}")

        if signal == 'Buy' and position == "Sell":
            shares = cash / price
            cash =- price
            position = "Buy"
        elif signal == 'Sell' and position == "Buy":
            cash = shares * price
            shares = 0
            position = "Sell"

        # Monthly investment
        if signal == 'Buy':
            cash += monthly_investment
            shares += cash / price
            cash =- price
        elif signal == 'Sell':
            cash += monthly_investment

    # Compute total equity
    final_stock_price = data['Price'].iloc[-1]
    total_equity = cash + (shares * final_stock_price)

    # Print final results
    print(f"Final Cash: {cash:.2f}, Final Shares: {shares:.4f}, Final Stock Price: {final_stock_price:.2f}, Total Equity: {total_equity:.2f}")
    return total_equity, cash + (shares * final_stock_price)

# Annual Return Calculation Function
def calculate_annual_return(final_value, total_invested, years=30):
    if total_invested == 0:
        return 0  # Avoid division by zero
    return ((final_value / total_invested) ** (1 / years)) - 1

# Simulate Strategies
bh_final_value, bh_total_invested = simulate_buy_and_hold(signals)
at_final_value, at_total_invested = simulate_active_trading(signals)

# Debugging Active Trading Results
print(f"AT Final Value: {at_final_value}, Total Invested: {at_total_invested}")

# Calculate annual percent return
bh_annual_return = calculate_annual_return(bh_final_value, bh_total_invested)
at_annual_return = calculate_annual_return(at_final_value, at_total_invested)

# Print the results
print(f"Buy and Hold Final Value: ${bh_final_value:.2f}, Annual Return: {bh_annual_return:.2%}")
print(f"Active Trading Final Value: ${at_final_value:.2f}, Annual Return: {at_annual_return:.2%}")

"""### Output"""

# Plotting the growth of money
def plot_growth(stock_data, signals):
    # Use the intersection of dates from stock_data and signals
    dates = stock_data.index.intersection(signals.index)  # Changed line

    bh_cumulative = [simulate_buy_and_hold(stock_data.loc[dates[:i + 1]])[0] for i in range(len(dates))]  # Changed line
    at_cumulative = [simulate_active_trading(signals.loc[dates[:i + 1]])[0] for i in range(len(dates))]  # Changed line

    plt.figure(figsize=(14, 8))
    plt.plot(dates, bh_cumulative, label='Buy and Hold', color='blue')
    plt.plot(dates, at_cumulative, label='Active Trading', color='green')
    plt.title('Investment Growth Over Time')
    plt.xlabel('Date')
    plt.ylabel('Portfolio Value ($)')
    plt.legend()
    plt.grid()
    plt.show()

plot_growth(stock_data, signals)